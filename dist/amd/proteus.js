/*! wire-webapp-proteus v1.0.5 */
define("proteus", [], function() { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 40);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var DontCallConstructor, ProteusError,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ProteusError = __webpack_require__(6);

  module.exports = DontCallConstructor = (function(superClass) {
    extend(DontCallConstructor, superClass);

    function DontCallConstructor(_instance) {
      this._instance = _instance;
      DontCallConstructor.__super__.constructor.call(this, "Instead of 'new " + this._instance.constructor.name + "', use '" + this._instance.constructor.name + ".new'.");
    }

    return DontCallConstructor;

  })(ProteusError);

}).call(this);


/***/ },
/* 1 */
/***/ function(module, exports) {

// Generated by CoffeeScript 1.11.1
(function() {
  module.exports = (function() {
    return {
      assert_is_instance: function(classes, inst) {
        var valid_types;
        if (!Array.isArray(classes)) {
          classes = [classes];
        }
        if (classes.some(function(k) {
          return inst instanceof k || (inst && inst.prototype instanceof k);
        })) {
          return;
        }
        valid_types = classes.map(function(k) {
          return "'" + k.name + "'";
        }).join(' or ');
        if (inst) {
          throw TypeError("Expected one of " + valid_types + ", got '" + inst.constructor.name + "'.");
        }
        throw TypeError("Expected one of " + valid_types + ", got '" + (String(inst)) + "'.");
      },
      assert_is_integer: function(inst) {
        if (Number.isInteger(inst)) {
          return;
        }
        if (inst) {
          throw new TypeError("Expected integer, got '" + inst.constructor.name + "'.");
        }
        throw new TypeError("Expected integer, got '" + (String(inst)) + "'.");
      }
    };
  })();

}).call(this);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var DontCallConstructor;

  DontCallConstructor = __webpack_require__(0);

  module.exports = (function() {
    return {
      new_instance: function(klass) {
        var e;
        try {
          return new klass;
        } catch (error) {
          e = error;
          if (!(e instanceof DontCallConstructor)) {
            throw e;
          }
          return e._instance;
        }
      }
    };
  })();

}).call(this);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  module.exports = {
    BaseError: __webpack_require__(30),
    DecodeError: __webpack_require__(23),
    Decoder: __webpack_require__(37),
    Encoder: __webpack_require__(38),
    Types: __webpack_require__(24)
  };

}).call(this);


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, PublicKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  module.exports = PublicKey = (function() {
    function PublicKey() {
      throw new DontCallConstructor(this);
    }

    PublicKey["new"] = function(pub_edward, pub_curve) {
      var pk;
      TypeUtil.assert_is_instance(Uint8Array, pub_edward);
      TypeUtil.assert_is_instance(Uint8Array, pub_curve);
      pk = ClassUtil.new_instance(PublicKey);
      pk.pub_edward = pub_edward;
      pk.pub_curve = pub_curve;
      return pk;
    };


    /*
    This function can be used to verify a message signature.
    
    @param signature [Uint8Array] The signature to verify
    @param message [String, Uint8Array] The message from which the signature was computed.
    @return [bool] `true` if the signature is valid, `false` otherwise.
     */

    PublicKey.prototype.verify = function(signature, message) {
      TypeUtil.assert_is_instance(Uint8Array, signature);
      return sodium.crypto_sign_verify_detached(signature, message, this.pub_edward);
    };

    PublicKey.prototype.fingerprint = function() {
      return sodium.to_hex(this.pub_edward);
    };

    PublicKey.prototype.encode = function(e) {
      e.object(1);
      e.u8(0);
      return e.bytes(this.pub_edward);
    };

    PublicKey.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(PublicKey);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.pub_edward = new Uint8Array(d.bytes());
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(Uint8Array, self.pub_edward);
      self.pub_curve = sodium.crypto_sign_ed25519_pk_to_curve25519(self.pub_edward);
      return self;
    };

    return PublicKey;

  })();

}).call(this);


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, KeyPair, PublicKey, SecretKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  PublicKey = __webpack_require__(4);

  SecretKey = __webpack_require__(19);


  /*
  Construct an ephemeral key pair.
   */

  module.exports = KeyPair = (function() {
    function KeyPair() {
      throw new DontCallConstructor(this);
    }

    KeyPair["new"] = function() {
      var ed25519_key_pair, kp;
      ed25519_key_pair = sodium.crypto_sign_keypair();
      kp = ClassUtil.new_instance(KeyPair);
      kp.secret_key = KeyPair.prototype._construct_private_key(ed25519_key_pair);
      kp.public_key = KeyPair.prototype._construct_public_key(ed25519_key_pair);
      return kp;
    };


    /*
    @note Ed25519 keys can be converted to Curve25519 keys, so that the same key pair can be used both for authenticated encryption (crypto_box) and for signatures (crypto_sign).
    @param ed25519_key_pair [Object] Key pair based on Edwards-curve (Ed25519)
    @option ed25519_key_pair [Uint8Array[32]] publicKey
    @option ed25519_key_pair [Uint8Array[64]] privateKey
    @option ed25519_key_pair [String] keyType
    @return [Proteus.keys.SecretKey] Constructed private key
    @see https://download.libsodium.org/doc/advanced/ed25519-curve25519.html
     */

    KeyPair.prototype._construct_private_key = function(ed25519_key_pair) {
      var sk_curve25519, sk_ed25519;
      sk_ed25519 = ed25519_key_pair.privateKey;
      sk_curve25519 = sodium.crypto_sign_ed25519_sk_to_curve25519(sk_ed25519);
      return SecretKey["new"](sk_ed25519, sk_curve25519);
    };


    /*
    @param ed25519_key_pair [libsodium.KeyPair] Key pair based on Edwards-curve (Ed25519)
    @return [Proteus.keys.PublicKey] Constructed public key
     */

    KeyPair.prototype._construct_public_key = function(ed25519_key_pair) {
      var pk_curve25519, pk_ed25519;
      pk_ed25519 = ed25519_key_pair.publicKey;
      pk_curve25519 = sodium.crypto_sign_ed25519_pk_to_curve25519(pk_ed25519);
      return PublicKey["new"](pk_ed25519, pk_curve25519);
    };

    KeyPair.prototype.encode = function(e) {
      e.object(2);
      e.u8(0);
      this.secret_key.encode(e);
      e.u8(1);
      return this.public_key.encode(e);
    };

    KeyPair.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(KeyPair);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.secret_key = SecretKey.decode(d);
            break;
          case 1:
            self.public_key = PublicKey.decode(d);
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(SecretKey, self.secret_key);
      TypeUtil.assert_is_instance(PublicKey, self.public_key);
      return self;
    };

    return KeyPair;

  })();

}).call(this);


/***/ },
/* 6 */
/***/ function(module, exports) {

// Generated by CoffeeScript 1.11.1
(function() {
  var ProteusError;

  module.exports = ProteusError = (function() {
    function ProteusError(message) {
      this.name = this.constructor.name;
      this.message = message;
      this.stack = (new Error).stack;
    }

    ProteusError.prototype = new Error;

    ProteusError.prototype.constructor = ProteusError;

    return ProteusError;

  })();

}).call(this);


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, IdentityKey, PublicKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  PublicKey = __webpack_require__(4);


  /*
  Construct a long-term identity key pair.
  
  Every client has a long-term identity key pair.
  Long-term identity keys are used to initialise “sessions” with other clients (triple DH).
   */

  module.exports = IdentityKey = (function() {
    function IdentityKey() {
      throw new DontCallConstructor(this);
    }

    IdentityKey["new"] = function(public_key) {
      var key;
      TypeUtil.assert_is_instance(PublicKey, public_key);
      key = ClassUtil.new_instance(IdentityKey);
      key.public_key = public_key;
      return key;
    };

    IdentityKey.prototype.fingerprint = function() {
      return this.public_key.fingerprint();
    };

    IdentityKey.prototype.toString = function() {
      return sodium.to_hex(this.public_key);
    };

    IdentityKey.prototype.encode = function(e) {
      e.object(1);
      e.u8(0);
      return this.public_key.encode(e);
    };

    IdentityKey.decode = function(d) {
      var i, nprops, public_key, ref;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      public_key = null;
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            public_key = PublicKey.decode(d);
            break;
          default:
            d.skip();
        }
      }
      return IdentityKey["new"](public_key);
    };

    return IdentityKey;

  })();

}).call(this);


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, CipherMessage, ClassUtil, DontCallConstructor, Message, PublicKey, SessionTag, TypeUtil,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  PublicKey = __webpack_require__(4);

  Message = __webpack_require__(14);

  SessionTag = __webpack_require__(22);

  module.exports = CipherMessage = (function(superClass) {
    extend(CipherMessage, superClass);

    function CipherMessage() {
      throw new DontCallConstructor(this);
    }

    CipherMessage["new"] = function(session_tag, counter, prev_counter, ratchet_key, cipher_text) {
      var cm;
      TypeUtil.assert_is_instance(SessionTag, session_tag);
      TypeUtil.assert_is_integer(counter);
      TypeUtil.assert_is_integer(prev_counter);
      TypeUtil.assert_is_instance(PublicKey, ratchet_key);
      TypeUtil.assert_is_instance(Uint8Array, cipher_text);
      cm = ClassUtil.new_instance(CipherMessage);
      cm.session_tag = session_tag;
      cm.counter = counter;
      cm.prev_counter = prev_counter;
      cm.ratchet_key = ratchet_key;
      cm.cipher_text = cipher_text;
      Object.freeze(cm);
      return cm;
    };

    CipherMessage.prototype.encode = function(e) {
      e.object(5);
      e.u8(0);
      this.session_tag.encode(e);
      e.u8(1);
      e.u32(this.counter);
      e.u8(2);
      e.u32(this.prev_counter);
      e.u8(3);
      this.ratchet_key.encode(e);
      e.u8(4);
      return e.bytes(this.cipher_text);
    };

    CipherMessage.decode = function(d) {
      var cipher_text, counter, i, nprops, prev_counter, ratchet_key, ref, session_tag;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      session_tag = null;
      counter = null;
      prev_counter = null;
      ratchet_key = null;
      cipher_text = null;
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            session_tag = SessionTag.decode(d);
            break;
          case 1:
            counter = d.u32();
            break;
          case 2:
            prev_counter = d.u32();
            break;
          case 3:
            ratchet_key = PublicKey.decode(d);
            break;
          case 4:
            cipher_text = new Uint8Array(d.bytes());
            break;
          default:
            d.skip();
        }
      }
      return CipherMessage["new"](session_tag, counter, prev_counter, ratchet_key, cipher_text);
    };

    return CipherMessage;

  })(Message);

}).call(this);


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ChainKey, ClassUtil, DerivedSecrets, DontCallConstructor, MacKey, MessageKeys, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  MacKey = __webpack_require__(16);

  DerivedSecrets = __webpack_require__(21);

  MessageKeys = __webpack_require__(28);

  module.exports = ChainKey = (function() {
    function ChainKey() {
      throw new DontCallConstructor(this);
    }


    /*
    @param key [Proteus.derived.MacKey] Mac Key generated by derived secrets
     */

    ChainKey.from_mac_key = function(key, counter) {
      var ck;
      TypeUtil.assert_is_instance(MacKey, key);
      TypeUtil.assert_is_integer(counter);
      ck = ClassUtil.new_instance(ChainKey);
      ck.key = key;
      ck.idx = counter;
      return ck;
    };

    ChainKey.prototype.next = function() {
      var ck;
      ck = ClassUtil.new_instance(ChainKey);
      ck.key = MacKey["new"](this.key.sign('1'));
      ck.idx = this.idx + 1;
      return ck;
    };

    ChainKey.prototype.message_keys = function() {
      var base, dsecs;
      base = this.key.sign('0');
      dsecs = DerivedSecrets.kdf_without_salt(base, 'hash_ratchet');
      return MessageKeys["new"](dsecs.cipher_key, dsecs.mac_key, this.idx);
    };

    ChainKey.prototype.encode = function(e) {
      e.object(2);
      e.u8(0);
      this.key.encode(e);
      e.u8(1);
      return e.u32(this.idx);
    };

    ChainKey.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(ChainKey);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.key = MacKey.decode(d);
            break;
          case 1:
            self.idx = d.u32();
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(MacKey, self.key);
      TypeUtil.assert_is_integer(self.idx);
      return self;
    };

    return ChainKey;

  })();

}).call(this);


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var DecodeError, ProteusError,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ProteusError = __webpack_require__(6);

  DecodeError = (function(superClass) {
    extend(DecodeError, superClass);

    function DecodeError(message) {
      this.message = message != null ? message : 'Unknown decoding error';
    }

    return DecodeError;

  })(ProteusError);

  DecodeError.InvalidType = (function(superClass) {
    extend(InvalidType, superClass);

    function InvalidType(message) {
      this.message = message != null ? message : 'Invalid type';
    }

    return InvalidType;

  })(DecodeError);

  DecodeError.InvalidArrayLen = (function(superClass) {
    extend(InvalidArrayLen, superClass);

    function InvalidArrayLen(message) {
      this.message = message != null ? message : 'Invalid array length';
    }

    return InvalidArrayLen;

  })(DecodeError);

  DecodeError.LocalIdentityChanged = (function(superClass) {
    extend(LocalIdentityChanged, superClass);

    function LocalIdentityChanged(message) {
      this.message = message != null ? message : 'Local identity changed';
    }

    return LocalIdentityChanged;

  })(DecodeError);

  module.exports = DecodeError;

}).call(this);


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var DecryptError, ProteusError,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ProteusError = __webpack_require__(6);

  DecryptError = (function(superClass) {
    extend(DecryptError, superClass);

    function DecryptError(message) {
      this.message = message != null ? message : 'Unknown decryption error';
    }

    return DecryptError;

  })(ProteusError);

  DecryptError.RemoteIdentityChanged = (function(superClass) {
    extend(RemoteIdentityChanged, superClass);

    function RemoteIdentityChanged(message) {
      this.message = message != null ? message : 'Remote identity changed';
    }

    return RemoteIdentityChanged;

  })(DecryptError);

  DecryptError.InvalidSignature = (function(superClass) {
    extend(InvalidSignature, superClass);

    function InvalidSignature(message) {
      this.message = message != null ? message : 'Invalid signature';
    }

    return InvalidSignature;

  })(DecryptError);

  DecryptError.InvalidMessage = (function(superClass) {
    extend(InvalidMessage, superClass);

    function InvalidMessage(message) {
      this.message = message != null ? message : 'Invalid message';
    }

    return InvalidMessage;

  })(DecryptError);

  DecryptError.DuplicateMessage = (function(superClass) {
    extend(DuplicateMessage, superClass);

    function DuplicateMessage(message) {
      this.message = message != null ? message : 'Duplicate message';
    }

    return DuplicateMessage;

  })(DecryptError);

  DecryptError.TooDistantFuture = (function(superClass) {
    extend(TooDistantFuture, superClass);

    function TooDistantFuture(message) {
      this.message = message != null ? message : 'Message is from too distant in the future';
    }

    return TooDistantFuture;

  })(DecryptError);

  DecryptError.OutdatedMessage = (function(superClass) {
    extend(OutdatedMessage, superClass);

    function OutdatedMessage(message) {
      this.message = message != null ? message : 'Outdated message';
    }

    return OutdatedMessage;

  })(DecryptError);

  DecryptError.PrekeyNotFound = (function(superClass) {
    extend(PrekeyNotFound, superClass);

    function PrekeyNotFound(message) {
      this.message = message != null ? message : 'Pre-key not found';
    }

    return PrekeyNotFound;

  })(DecryptError);

  module.exports = DecryptError;

}).call(this);


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, IdentityKey, IdentityKeyPair, KeyPair, SecretKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  IdentityKey = __webpack_require__(7);

  SecretKey = __webpack_require__(19);

  KeyPair = __webpack_require__(5);

  module.exports = IdentityKeyPair = (function() {
    function IdentityKeyPair() {
      throw new DontCallConstructor(this);
    }

    IdentityKeyPair["new"] = function() {
      var ikp, key_pair;
      key_pair = KeyPair["new"]();
      ikp = ClassUtil.new_instance(IdentityKeyPair);
      ikp.version = 1;
      ikp.secret_key = key_pair.secret_key;
      ikp.public_key = IdentityKey["new"](key_pair.public_key);
      return ikp;
    };

    IdentityKeyPair.prototype.serialise = function() {
      var e;
      e = new CBOR.Encoder();
      this.encode(e);
      return e.get_buffer();
    };

    IdentityKeyPair.deserialise = function(buf) {
      var d;
      TypeUtil.assert_is_instance(ArrayBuffer, buf);
      d = new CBOR.Decoder(buf);
      return IdentityKeyPair.decode(d);
    };

    IdentityKeyPair.prototype.encode = function(e) {
      e.object(3);
      e.u8(0);
      e.u8(this.version);
      e.u8(1);
      this.secret_key.encode(e);
      e.u8(2);
      return this.public_key.encode(e);
    };

    IdentityKeyPair.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(IdentityKeyPair);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.version = d.u8();
            break;
          case 1:
            self.secret_key = SecretKey.decode(d);
            break;
          case 2:
            self.public_key = IdentityKey.decode(d);
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_integer(self.version);
      TypeUtil.assert_is_instance(SecretKey, self.secret_key);
      TypeUtil.assert_is_instance(IdentityKey, self.public_key);
      return self;
    };

    return IdentityKeyPair;

  })();

}).call(this);


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, Envelope, MacKey, Message, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  MacKey = __webpack_require__(16);

  Message = __webpack_require__(14);

  module.exports = Envelope = (function() {
    function Envelope() {
      throw new DontCallConstructor(this);
    }

    Envelope["new"] = function(mac_key, message) {
      var env, message_enc;
      TypeUtil.assert_is_instance(MacKey, mac_key);
      TypeUtil.assert_is_instance(Message, message);
      message_enc = new Uint8Array(message.serialise());
      env = ClassUtil.new_instance(Envelope);
      env.version = 1;
      env.mac = mac_key.sign(message_enc);
      env.message = message;
      env._message_enc = message_enc;
      Object.freeze(env);
      return env;
    };

    Envelope.prototype.verify = function(mac_key) {
      TypeUtil.assert_is_instance(MacKey, mac_key);
      return mac_key.verify(this.mac, this._message_enc);
    };


    /*
    @return [ArrayBuffer] The serialized message envelope
     */

    Envelope.prototype.serialise = function() {
      var e;
      e = new CBOR.Encoder();
      this.encode(e);
      return e.get_buffer();
    };

    Envelope.deserialise = function(buf) {
      var d;
      TypeUtil.assert_is_instance(ArrayBuffer, buf);
      d = new CBOR.Decoder(buf);
      return Envelope.decode(d);
    };

    Envelope.prototype.encode = function(e) {
      e.object(3);
      e.u8(0);
      e.u8(this.version);
      e.u8(1);
      e.object(1);
      e.u8(0);
      e.bytes(this.mac);
      e.u8(2);
      return e.bytes(this._message_enc);
    };

    Envelope.decode = function(d) {
      var env, i, j, nprops, nprops_mac, ref, ref1;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      env = ClassUtil.new_instance(Envelope);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            env.version = d.u8();
            break;
          case 1:
            nprops_mac = d.object();
            for (j = 0, ref1 = nprops_mac - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; 0 <= ref1 ? j++ : j--) {
              switch (d.u8()) {
                case 0:
                  env.mac = new Uint8Array(d.bytes());
                  break;
                default:
                  d.skip();
              }
            }
            break;
          case 2:
            env._message_enc = new Uint8Array(d.bytes());
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_integer(env.version);
      TypeUtil.assert_is_instance(Uint8Array, env.mac);
      env.message = Message.deserialise(env._message_enc.buffer);
      Object.freeze(env);
      return env;
    };

    return Envelope;

  })();

}).call(this);


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, CipherMessage, DecodeError, DontCallConstructor, Message, PreKeyMessage, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  TypeUtil = __webpack_require__(1);

  DecodeError = __webpack_require__(10);

  module.exports = Message = (function() {
    function Message() {
      throw new DontCallConstructor(this);
    }

    Message.prototype.serialise = function() {
      var e;
      e = new CBOR.Encoder();
      switch (false) {
        case !(this instanceof CipherMessage):
          e.u8(1);
          break;
        case !(this instanceof PreKeyMessage):
          e.u8(2);
          break;
        default:
          throw new TypeError('Unexpected message type');
      }
      this.encode(e);
      return e.get_buffer();
    };

    Message.deserialise = function(buf) {
      var d;
      TypeUtil.assert_is_instance(ArrayBuffer, buf);
      d = new CBOR.Decoder(buf);
      switch (d.u8()) {
        case 1:
          return CipherMessage.decode(d);
        case 2:
          return PreKeyMessage.decode(d);
        default:
          throw new DecodeError.InvalidType('Unrecognised message type');
      }
    };

    return Message;

  })();

  CipherMessage = __webpack_require__(8);

  PreKeyMessage = __webpack_require__(15);

}).call(this);


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, CipherMessage, ClassUtil, DontCallConstructor, IdentityKey, Message, PreKeyMessage, PublicKey, TypeUtil,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  PublicKey = __webpack_require__(4);

  IdentityKey = __webpack_require__(7);

  Message = __webpack_require__(14);

  CipherMessage = __webpack_require__(8);

  module.exports = PreKeyMessage = (function(superClass) {
    extend(PreKeyMessage, superClass);

    function PreKeyMessage() {
      throw new DontCallConstructor(this);
    }

    PreKeyMessage["new"] = function(prekey_id, base_key, identity_key, message) {
      var pkm;
      TypeUtil.assert_is_integer(prekey_id);
      TypeUtil.assert_is_instance(PublicKey, base_key);
      TypeUtil.assert_is_instance(IdentityKey, identity_key);
      TypeUtil.assert_is_instance(CipherMessage, message);
      pkm = ClassUtil.new_instance(PreKeyMessage);
      pkm.prekey_id = prekey_id;
      pkm.base_key = base_key;
      pkm.identity_key = identity_key;
      pkm.message = message;
      Object.freeze(pkm);
      return pkm;
    };

    PreKeyMessage.prototype.encode = function(e) {
      e.object(4);
      e.u8(0);
      e.u16(this.prekey_id);
      e.u8(1);
      this.base_key.encode(e);
      e.u8(2);
      this.identity_key.encode(e);
      e.u8(3);
      return this.message.encode(e);
    };

    PreKeyMessage.decode = function(d) {
      var base_key, i, identity_key, message, nprops, prekey_id, ref;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      prekey_id = null;
      base_key = null;
      identity_key = null;
      message = null;
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            prekey_id = d.u16();
            break;
          case 1:
            base_key = PublicKey.decode(d);
            break;
          case 2:
            identity_key = IdentityKey.decode(d);
            break;
          case 3:
            message = CipherMessage.decode(d);
            break;
          default:
            d.skip();
        }
      }
      return PreKeyMessage["new"](prekey_id, base_key, identity_key, message);
    };

    return PreKeyMessage;

  })(Message);

}).call(this);


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, MacKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  module.exports = MacKey = (function() {
    function MacKey() {
      throw new DontCallConstructor(this);
    }


    /*
    key: mac::Key
    @param key [Uint8Array] Mac Key in byte array format generated by derived secrets
     */

    MacKey["new"] = function(key) {
      var mk;
      TypeUtil.assert_is_instance(Uint8Array, key);
      mk = ClassUtil.new_instance(MacKey);
      mk.key = key;
      return mk;
    };


    /*
    Hash-based message authentication code
     */

    MacKey.prototype.sign = function(msg) {
      return sodium.crypto_auth_hmacsha256(msg, this.key);
    };

    MacKey.prototype.verify = function(signature, msg) {
      return sodium.crypto_auth_hmacsha256_verify(signature, msg, this.key);
    };

    MacKey.prototype.encode = function(e) {
      e.object(1);
      e.u8(0);
      return e.bytes(this.key);
    };

    MacKey.decode = function(d) {
      var i, key_bytes, nprops, ref;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      key_bytes = null;
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            key_bytes = new Uint8Array(d.bytes());
            break;
          default:
            d.skip();
        }
      }
      return MacKey["new"](key_bytes);
    };

    return MacKey;

  })();

}).call(this);


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, KeyPair, PreKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  KeyPair = __webpack_require__(5);


  /*
  Pre-generated (and regularly refreshed) pre-keys.
  A Pre-Shared Key contains the public long-term identity and ephemeral handshake keys for the initial triple DH.
   */

  module.exports = PreKey = (function() {
    PreKey.MAX_PREKEY_ID = 0xFFFF;

    function PreKey() {
      throw new DontCallConstructor(this);
    }


    /*
    @param pre_key_id [Integer]
     */

    PreKey["new"] = function(pre_key_id) {
      var pk;
      TypeUtil.assert_is_integer(pre_key_id);
      if (pre_key_id < 0 || pre_key_id > PreKey.MAX_PREKEY_ID) {
        throw new RangeError("pre_key_id must be between 0 and " + PreKey.MAX_PREKEY_ID + " inclusive");
      }
      pk = ClassUtil.new_instance(PreKey);
      pk.version = 1;
      pk.key_id = pre_key_id;
      pk.key_pair = KeyPair["new"]();
      return pk;
    };

    PreKey.last_resort = function() {
      return PreKey["new"](PreKey.MAX_PREKEY_ID);
    };

    PreKey.generate_prekeys = function(start, size) {
      var check_integer, i, ref, results;
      check_integer = function(value) {
        TypeUtil.assert_is_integer(value);
        if (value < 0 || value > PreKey.MAX_PREKEY_ID) {
          throw new RangeError("Arguments must be between 0 and " + PreKey.MAX_PREKEY_ID + " inclusive");
        }
      };
      check_integer(start);
      check_integer(size);
      return (function() {
        results = [];
        for (var i = 0, ref = size - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this).map(function(x) {
        return PreKey["new"]((start + x) % PreKey.MAX_PREKEY_ID);
      });
    };

    PreKey.prototype.serialise = function() {
      var e;
      e = new CBOR.Encoder();
      this.encode(e);
      return e.get_buffer();
    };

    PreKey.deserialise = function(buf) {
      TypeUtil.assert_is_instance(ArrayBuffer, buf);
      return PreKey.decode(new CBOR.Decoder(buf));
    };

    PreKey.prototype.encode = function(e) {
      TypeUtil.assert_is_instance(CBOR.Encoder, e);
      e.object(3);
      e.u8(0);
      e.u8(this.version);
      e.u8(1);
      e.u16(this.key_id);
      e.u8(2);
      return this.key_pair.encode(e);
    };

    PreKey.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(PreKey);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.version = d.u8();
            break;
          case 1:
            self.key_id = d.u16();
            break;
          case 2:
            self.key_pair = KeyPair.decode(d);
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_integer(self.version);
      TypeUtil.assert_is_integer(self.key_id);
      TypeUtil.assert_is_instance(KeyPair, self.key_pair);
      return self;
    };

    return PreKey;

  })();

}).call(this);


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, IdentityKey, IdentityKeyPair, PreKey, PreKeyAuth, PreKeyBundle, PublicKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  IdentityKeyPair = __webpack_require__(12);

  IdentityKey = __webpack_require__(7);

  PreKeyAuth = __webpack_require__(25);

  PublicKey = __webpack_require__(4);

  PreKey = __webpack_require__(17);

  module.exports = PreKeyBundle = (function() {
    function PreKeyBundle() {
      throw new DontCallConstructor(this);
    }


    /*
    @param identity_key [Proteus.keys.IdentityKey]
    @param prekey [Proteus.keys.PreKey]
     */

    PreKeyBundle["new"] = function(identity_key, prekey) {
      var bundle;
      TypeUtil.assert_is_instance(IdentityKey, identity_key);
      TypeUtil.assert_is_instance(PreKey, prekey);
      bundle = ClassUtil.new_instance(PreKeyBundle);
      bundle.version = 1;
      bundle.prekey_id = prekey.key_id;
      bundle.public_key = prekey.key_pair.public_key;
      bundle.identity_key = identity_key;
      bundle.signature = null;
      return bundle;
    };

    PreKeyBundle.signed = function(identity_pair, prekey) {
      var bundle, ratchet_key, signature;
      TypeUtil.assert_is_instance(IdentityKeyPair, identity_pair);
      TypeUtil.assert_is_instance(PreKey, prekey);
      ratchet_key = prekey.key_pair.public_key;
      signature = identity_pair.secret_key.sign(ratchet_key.pub_edward);
      bundle = ClassUtil.new_instance(PreKeyBundle);
      bundle.version = 1;
      bundle.prekey_id = prekey.key_id;
      bundle.public_key = ratchet_key;
      bundle.identity_key = identity_pair.public_key;
      bundle.signature = signature;
      return bundle;
    };

    PreKeyBundle.prototype.verify = function() {
      if (!this.signature) {
        return PreKeyAuth.UNKNOWN;
      }
      if (this.identity_key.public_key.verify(this.signature, this.public_key.pub_edward)) {
        return PreKeyAuth.VALID;
      }
      return PreKeyAuth.INVALID;
    };

    PreKeyBundle.prototype.serialise = function() {
      var e;
      e = new CBOR.Encoder();
      this.encode(e);
      return e.get_buffer();
    };

    PreKeyBundle.deserialise = function(buf) {
      TypeUtil.assert_is_instance(ArrayBuffer, buf);
      return PreKeyBundle.decode(new CBOR.Decoder(buf));
    };

    PreKeyBundle.prototype.encode = function(e) {
      TypeUtil.assert_is_instance(CBOR.Encoder, e);
      e.object(5);
      e.u8(0);
      e.u8(this.version);
      e.u8(1);
      e.u16(this.prekey_id);
      e.u8(2);
      this.public_key.encode(e);
      e.u8(3);
      this.identity_key.encode(e);
      e.u8(4);
      if (!this.signature) {
        return e["null"]();
      } else {
        return e.bytes(this.signature);
      }
    };

    PreKeyBundle.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(PreKeyBundle);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.version = d.u8();
            break;
          case 1:
            self.prekey_id = d.u16();
            break;
          case 2:
            self.public_key = PublicKey.decode(d);
            break;
          case 3:
            self.identity_key = IdentityKey.decode(d);
            break;
          case 4:
            self.signature = d.optional(function() {
              return new Uint8Array(d.bytes());
            });
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_integer(self.version);
      TypeUtil.assert_is_integer(self.prekey_id);
      TypeUtil.assert_is_instance(PublicKey, self.public_key);
      TypeUtil.assert_is_instance(IdentityKey, self.identity_key);
      return self;
    };

    return PreKeyBundle;

  })();

}).call(this);


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DontCallConstructor, PublicKey, SecretKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  PublicKey = __webpack_require__(4);

  module.exports = SecretKey = (function() {
    function SecretKey() {
      throw new DontCallConstructor(this);
    }

    SecretKey["new"] = function(sec_edward, sec_curve) {
      var sk;
      TypeUtil.assert_is_instance(Uint8Array, sec_edward);
      TypeUtil.assert_is_instance(Uint8Array, sec_curve);
      sk = ClassUtil.new_instance(SecretKey);
      sk.sec_edward = sec_edward;
      sk.sec_curve = sec_curve;
      return sk;
    };


    /*
    This function can be used to compute a message signature.
    
    @param message [String, Uint8Array] Message to be signed
    @return [Uint8Array] A message signature
     */

    SecretKey.prototype.sign = function(message) {
      return sodium.crypto_sign_detached(message, this.sec_edward);
    };


    /*
    This function can be used to compute a shared secret given a user's secret key and another user's public key.
    
    @param public_key [Proteus.keys.PublicKey] Another user's public key
    @return [Uint8Array] Array buffer view of the computed shared secret
     */

    SecretKey.prototype.shared_secret = function(public_key) {
      TypeUtil.assert_is_instance(PublicKey, public_key);
      return sodium.crypto_scalarmult(this.sec_curve, public_key.pub_curve);
    };

    SecretKey.prototype.encode = function(e) {
      e.object(1);
      e.u8(0);
      return e.bytes(this.sec_edward);
    };

    SecretKey.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(SecretKey);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.sec_edward = new Uint8Array(d.bytes());
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(Uint8Array, self.sec_edward);
      self.sec_curve = sodium.crypto_sign_ed25519_sk_to_curve25519(self.sec_edward);
      return self;
    };

    return SecretKey;

  })();

}).call(this);


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, CipherKey, ClassUtil, DontCallConstructor, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  module.exports = CipherKey = (function() {
    function CipherKey() {
      throw new DontCallConstructor(this);
    }

    CipherKey["new"] = function(key) {
      var ck;
      TypeUtil.assert_is_instance(Uint8Array, key);
      ck = ClassUtil.new_instance(CipherKey);
      ck.key = key;
      return ck;
    };


    /*
    @param plaintext [String, ArrayBuffer] The text to encrypt
    @param nonce [Uint8Array] Counter as nonce
    @return [Uint8Array] Encypted payload
     */

    CipherKey.prototype.encrypt = function(plaintext, nonce) {
      if (plaintext instanceof ArrayBuffer && plaintext.byteLength !== void 0) {
        plaintext = new Uint8Array(plaintext);
      }
      return sodium.crypto_stream_chacha20_xor(plaintext, nonce, this.key, 'uint8array');
    };

    CipherKey.prototype.decrypt = function(ciphertext, nonce) {
      return this.encrypt(ciphertext, nonce);
    };

    CipherKey.prototype.encode = function(e) {
      e.object(1);
      e.u8(0);
      return e.bytes(this.key);
    };

    CipherKey.decode = function(d) {
      var i, key_bytes, nprops, ref;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      key_bytes = null;
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            key_bytes = new Uint8Array(d.bytes());
            break;
          default:
            d.skip();
        }
      }
      return CipherKey["new"](key_bytes);
    };

    return CipherKey;

  })();

}).call(this);


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CipherKey, ClassUtil, DerivedSecrets, DontCallConstructor, KeyDerivationUtil, MacKey;

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  KeyDerivationUtil = __webpack_require__(35);

  CipherKey = __webpack_require__(20);

  MacKey = __webpack_require__(16);

  module.exports = DerivedSecrets = (function() {
    function DerivedSecrets() {
      throw new DontCallConstructor(this);
    }

    DerivedSecrets.kdf = function(input, salt, info) {
      var byte_length, cipher_key, ds, mac_key, okm;
      byte_length = 64;
      okm = KeyDerivationUtil.hkdf(salt, input, info, byte_length);
      cipher_key = new Uint8Array(okm.buffer.slice(0, 32));
      mac_key = new Uint8Array(okm.buffer.slice(32, 64));
      ds = ClassUtil.new_instance(DerivedSecrets);
      ds.cipher_key = CipherKey["new"](cipher_key);
      ds.mac_key = MacKey["new"](mac_key);
      return ds;
    };


    /*
    @param input [Array<Integer>] Initial key material (usually the Master Key) in byte array format
    @param info [String] Key Derivation Data
     */

    DerivedSecrets.kdf_without_salt = function(input, info) {
      return this.kdf(input, new Uint8Array(0), info);
    };

    return DerivedSecrets;

  })();

}).call(this);


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ClassUtil, DecodeError, DontCallConstructor, RandomUtil, SessionTag, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  DecodeError = __webpack_require__(10);

  RandomUtil = __webpack_require__(36);

  module.exports = SessionTag = (function() {
    function SessionTag() {
      throw new DontCallConstructor(this);
    }

    SessionTag["new"] = function() {
      var st;
      st = ClassUtil.new_instance(SessionTag);
      st.tag = RandomUtil.random_bytes(16);
      return st;
    };

    SessionTag.prototype.toString = function() {
      return sodium.to_hex(this.tag);
    };

    SessionTag.prototype.encode = function(e) {
      return e.bytes(this.tag);
    };

    SessionTag.decode = function(d) {
      var bytes, st;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      bytes = new Uint8Array(d.bytes());
      if (bytes.byteLength !== 16) {
        throw DecodeError.InvalidArrayLen("SessionTag should be 16 bytes, not " + bytes.byteLength + " bytes.");
      }
      st = ClassUtil.new_instance(SessionTag);
      st.tag = new Uint8Array(bytes);
      return st;
    };

    return SessionTag;

  })();

}).call(this);


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var BaseError, DecodeError,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BaseError = __webpack_require__(30);

  module.exports = DecodeError = (function(superClass) {
    extend(DecodeError, superClass);

    DecodeError.prototype.INVALID_TYPE = 'Invalid type';

    DecodeError.prototype.UNEXPECTED_EOF = 'Unexpected end-of-buffer';

    DecodeError.prototype.UNEXPECTED_TYPE = 'Unexpected type';

    DecodeError.prototype.INT_OVERFLOW = 'Integer overflow';

    DecodeError.prototype.TOO_LONG = 'Field too long';

    DecodeError.prototype.TOO_NESTED = 'Object nested too deep';

    function DecodeError(message, extra) {
      this.extra = extra;
      DecodeError.__super__.constructor.call(this, message);
    }

    return DecodeError;

  })(BaseError);

}).call(this);


/***/ },
/* 24 */
/***/ function(module, exports) {

// Generated by CoffeeScript 1.11.1
(function() {
  var Types;

  module.exports = Types = (function() {
    Types.prototype.ARRAY = 1;

    Types.prototype.BOOL = 2;

    Types.prototype.BREAK = 3;

    Types.prototype.BYTES = 4;

    Types.prototype.FLOAT16 = 5;

    Types.prototype.FLOAT32 = 6;

    Types.prototype.FLOAT64 = 7;

    Types.prototype.UINT8 = 8;

    Types.prototype.UINT16 = 9;

    Types.prototype.UINT32 = 10;

    Types.prototype.UINT64 = 11;

    Types.prototype.INT8 = 12;

    Types.prototype.INT16 = 13;

    Types.prototype.INT32 = 14;

    Types.prototype.INT64 = 15;

    Types.prototype.NULL = 16;

    Types.prototype.OBJECT = 17;

    Types.prototype.TAGGED = 18;

    Types.prototype.TEXT = 19;

    Types.prototype.UNDEFINED = 20;

    function Types() {
      raise(new Error('Can\'t create instance of singleton'));
    }

    Types.major = function(t) {
      switch (t) {
        case Types.prototype.ARRAY:
          return 4;
        case Types.prototype.BOOL:
          return 7;
        case Types.prototype.BREAK:
          return 7;
        case Types.prototype.BYTES:
          return 2;
        case Types.prototype.FLOAT16:
          return 7;
        case Types.prototype.FLOAT32:
          return 7;
        case Types.prototype.FLOAT64:
          return 7;
        case Types.prototype.UINT8:
          return 0;
        case Types.prototype.UINT16:
          return 0;
        case Types.prototype.UINT32:
          return 0;
        case Types.prototype.UINT64:
          return 0;
        case Types.prototype.INT8:
          return 1;
        case Types.prototype.INT16:
          return 1;
        case Types.prototype.INT32:
          return 1;
        case Types.prototype.INT64:
          return 1;
        case Types.prototype.NULL:
          return 7;
        case Types.prototype.OBJECT:
          return 5;
        case Types.prototype.TAGGED:
          return 6;
        case Types.prototype.TEXT:
          return 3;
        case Types.prototype.UNDEFINED:
          return 7;
        default:
          return raise(TypeError('Invalid CBOR type'));
      }
    };

    return Types;

  })();

}).call(this);


/***/ },
/* 25 */
/***/ function(module, exports) {

// Generated by CoffeeScript 1.11.1
(function() {
  module.exports = {
    INVALID: 'Invalid',
    UNKNOWN: 'Unknown',
    VALID: 'Valid'
  };

}).call(this);


/***/ },
/* 26 */
/***/ function(module, exports) {

// Generated by CoffeeScript 1.11.1
(function() {
  var PreKeyStore;

  module.exports = PreKeyStore = (function() {
    function PreKeyStore() {}

    PreKeyStore.prototype.get_prekey = function(prekey_id) {
      throw Error('Virtual function unimplemented');
    };

    PreKeyStore.prototype.remove = function(prekey_id) {
      throw Error('Virtual function unimplemented');
    };

    return PreKeyStore;

  })();

}).call(this);


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ChainKey, CipherMessage, ClassUtil, DecodeError, DecryptError, DontCallConstructor, Envelope, IdentityKey, IdentityKeyPair, KeyPair, PreKey, PreKeyBundle, PreKeyMessage, PreKeyStore, ProteusError, PublicKey, Session, SessionState, SessionTag, TypeUtil,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  ProteusError = __webpack_require__(6);

  DecryptError = __webpack_require__(11);

  DecodeError = __webpack_require__(10);

  IdentityKeyPair = __webpack_require__(12);

  IdentityKey = __webpack_require__(7);

  PreKeyBundle = __webpack_require__(18);

  PublicKey = __webpack_require__(4);

  KeyPair = __webpack_require__(5);

  PreKey = __webpack_require__(17);

  Envelope = __webpack_require__(13);

  CipherMessage = __webpack_require__(8);

  PreKeyMessage = __webpack_require__(15);

  SessionTag = __webpack_require__(22);

  PreKeyStore = __webpack_require__(26);

  ChainKey = __webpack_require__(9);

  module.exports = Session = (function() {
    Session.MAX_RECV_CHAINS = 5;

    Session.MAX_SESSION_STATES = 100;

    function Session() {
      this.counter = 0;
      this.local_identity = null;
      this.pending_prekey = null;
      this.remote_identity = null;
      this.session_states = null;
      this.session_tag = null;
      this.version = 1;
      throw new DontCallConstructor(this);
    }


    /*
    @param local_identity [IdentityKeyPair] Alice's Identity Key Pair
    @param remote_pkbundle [Proteus.keys.PreKeyBundle] Bob's Pre-Key Bundle
     */

    Session.init_from_prekey = function(local_identity, remote_pkbundle) {
      var alice_base, session, session_tag, state;
      TypeUtil.assert_is_instance(IdentityKeyPair, local_identity);
      TypeUtil.assert_is_instance(PreKeyBundle, remote_pkbundle);
      alice_base = KeyPair["new"]();
      state = SessionState.init_as_alice(local_identity, alice_base, remote_pkbundle);
      session_tag = SessionTag["new"]();
      session = ClassUtil.new_instance(Session);
      session.session_tag = session_tag;
      session.local_identity = local_identity;
      session.remote_identity = remote_pkbundle.identity_key;
      session.pending_prekey = [remote_pkbundle.prekey_id, alice_base.public_key];
      session.session_states = {};
      session._insert_session_state(session_tag, state);
      return session;
    };

    Session.init_from_message = function(our_identity, prekey_store, envelope) {
      var pkmsg, plain, session, state;
      TypeUtil.assert_is_instance(IdentityKeyPair, our_identity);
      TypeUtil.assert_is_instance(PreKeyStore, prekey_store);
      TypeUtil.assert_is_instance(Envelope, envelope);
      pkmsg = (function() {
        switch (false) {
          case !(envelope.message instanceof CipherMessage):
            throw new DecryptError.InvalidMessage('Can\'t initialise a session from a CipherMessage.');
            break;
          case !(envelope.message instanceof PreKeyMessage):
            return envelope.message;
          default:
            throw new DecryptError.InvalidMessage;
        }
      })();
      session = ClassUtil.new_instance(Session);
      session.session_tag = pkmsg.message.session_tag;
      session.local_identity = our_identity;
      session.remote_identity = pkmsg.identity_key;
      session.pending_prekey = null;
      session.session_states = {};
      state = session._new_state(prekey_store, pkmsg);
      if (!state) {
        throw new DecryptError.PrekeyNotFound;
      }
      plain = state.decrypt(envelope, pkmsg.message);
      session._insert_session_state(pkmsg.message.session_tag, state);
      if (pkmsg.prekey_id < PreKey.MAX_PREKEY_ID) {
        prekey_store.remove(pkmsg.prekey_id);
      }
      return [session, plain];
    };

    Session.prototype._new_state = function(prekey_store, prekey_message) {
      var prekey;
      prekey = prekey_store.get_prekey(prekey_message.prekey_id);
      if (!prekey) {
        return null;
      }
      return SessionState.init_as_bob(this.local_identity, prekey.key_pair, prekey_message.identity_key, prekey_message.base_key);
    };

    Session.prototype._insert_session_state = function(tag, state) {
      var obj_size;
      if (indexOf.call(this.session_states, tag) >= 0) {
        this.session_states[tag].state = state;
      } else {
        if (this.counter >= Number.MAX_SAFE_INTEGER) {
          this.session_states = {};
          this.counter = 0;
        }
        this.session_states[tag] = {
          idx: this.counter,
          tag: tag,
          state: state
        };
        this.counter++;
      }
      if (this.session_tag.toString() !== tag.toString()) {
        this.session_tag = tag;
      }
      obj_size = function(obj) {
        return Object.keys(obj).length;
      };
      if (obj_size(this.session_states) < Session.MAX_SESSION_STATES) {
        return;
      }
      return this._evict_oldest_session_state();
    };

    Session.prototype._evict_oldest_session_state = function() {
      var k, oldest, reduction, states, v;
      states = (function() {
        var j, len, ref, results;
        ref = this.session_states;
        results = [];
        for (v = j = 0, len = ref.length; j < len; v = ++j) {
          k = ref[v];
          if (k.toString() !== this.session_tag.toString()) {
            results.push([k, v]);
          }
        }
        return results;
      }).call(this);
      reduction = function(accumulator, item) {
        var tag, val;
        tag = item[0];
        val = item[1];
        if (!accumulator || val.idx < accumulator.idx) {
          return {
            idx: val.idx,
            tag: k
          };
        }
        return accumulator;
      };
      oldest = states.reduce(reduction, null);
      return delete this.session_states[oldest.tag];
    };

    Session.prototype.get_local_identity = function() {
      return this.local_identity.public_key;
    };


    /*
    @param plaintext [String, Uint8Array] The plaintext which needs to be encrypted
    @return [Proteus.message.Envelope] Encrypted message
     */

    Session.prototype.encrypt = function(plaintext) {
      var state;
      state = this.session_states[this.session_tag];
      if (!state) {
        throw new ProteusError('No session for tag');
      }
      return state.state.encrypt(this.local_identity.public_key, this.pending_prekey, this.session_tag, plaintext);
    };


    /*
    @param prekey_store [Proteus.session.PreKeyStore] Store from which we can fetch local PreKeys
    @param envelope [Proteus.message.Envelope] Encrypted message
    @return [Uint8Array] Decrypted message (aka plaintext)
     */

    Session.prototype.decrypt = function(prekey_store, envelope) {
      var decrypt_error, e, msg, plaintext, state;
      TypeUtil.assert_is_instance(PreKeyStore, prekey_store);
      TypeUtil.assert_is_instance(Envelope, envelope);
      msg = envelope.message;
      switch (false) {
        case !(msg instanceof CipherMessage):
          return this._decrypt_cipher_message(envelope, envelope.message);
        case !(msg instanceof PreKeyMessage):
          if (msg.identity_key.fingerprint() !== this.remote_identity.fingerprint()) {
            throw new DecryptError.RemoteIdentityChanged;
          }
          decrypt_error = null;
          try {
            return this._decrypt_cipher_message(envelope, msg.message);
          } catch (error) {
            e = error;
            decrypt_error = e;
            if (!(e instanceof DecryptError.InvalidSignature || e instanceof DecryptError.InvalidMessage)) {
              throw e;
            }
          }
          state = this._new_state(prekey_store, msg);
          if (!state) {
            throw decrypt_error;
          }
          plaintext = state.decrypt(envelope, msg.message);
          if (msg.prekey_id !== PreKey.MAX_PREKEY_ID) {
            prekey_store.remove(msg.prekey_id);
          }
          this._insert_session_state(msg.message.session_tag, state);
          this.pending_prekey = null;
          return plaintext;
      }
    };

    Session.prototype._decrypt_cipher_message = function(envelope, msg) {
      var plaintext, state;
      state = this.session_states[msg.session_tag];
      if (!state) {
        throw new DecryptError.InvalidMessage('No matching session state.');
      }
      state = SessionState.deserialise(state.state.serialise());
      plaintext = state.decrypt(envelope, msg);
      this.pending_prekey = null;
      this._insert_session_state(msg.session_tag, state);
      return plaintext;
    };

    Session.prototype.serialise = function() {
      var e;
      e = new CBOR.Encoder();
      this.encode(e);
      return e.get_buffer();
    };

    Session.deserialise = function(local_identity, buf) {
      var d;
      TypeUtil.assert_is_instance(IdentityKeyPair, local_identity);
      TypeUtil.assert_is_instance(ArrayBuffer, buf);
      d = new CBOR.Decoder(buf);
      return Session.decode(local_identity, d);
    };

    Session.prototype.encode = function(e) {
      var _, ref, results, state;
      e.object(6);
      e.u8(0);
      e.u8(this.version);
      e.u8(1);
      this.session_tag.encode(e);
      e.u8(2);
      this.local_identity.public_key.encode(e);
      e.u8(3);
      this.remote_identity.encode(e);
      e.u8(4);
      if (this.pending_prekey) {
        e.object(2);
        e.u8(0);
        e.u16(this.pending_prekey[0]);
        e.u8(1);
        this.pending_prekey[1].encode(e);
      } else {
        e["null"]();
      }
      e.u8(5);
      e.object(Object.keys(this.session_states).length);
      ref = this.session_states;
      results = [];
      for (_ in ref) {
        state = ref[_];
        state.tag.encode(e);
        results.push(state.state.encode(e));
      }
      return results;
    };

    Session.decode = function(local_identity, d) {
      var _, i, ik, j, l, m, nprops, ref, ref1, self, tag;
      TypeUtil.assert_is_instance(IdentityKeyPair, local_identity);
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(Session);
      nprops = d.object();
      for (j = 0, ref = nprops - 1; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--) {
        switch (d.u8()) {
          case 0:
            self.version = d.u8();
            break;
          case 1:
            self.session_tag = SessionTag.decode(d);
            break;
          case 2:
            ik = IdentityKey.decode(d);
            if (local_identity.public_key.fingerprint() !== ik.fingerprint()) {
              throw new DecodeError.LocalIdentityChanged;
            }
            self.local_identity = local_identity;
            break;
          case 3:
            self.remote_identity = IdentityKey.decode(d);
            break;
          case 4:
            switch (d.optional(function() {
                  return d.object();
                })) {
              case null:
                self.pending_prekey = null;
                break;
              case 2:
                self.pending_prekey = [null, null];
                for (_ = l = 0; l <= 1; _ = ++l) {
                  switch (d.u8()) {
                    case 0:
                      self.pending_prekey[0] = d.u16();
                      break;
                    case 1:
                      self.pending_prekey[1] = PublicKey.decode(d);
                  }
                }
                break;
              default:
                throw new DecodeError.InvalidType;
            }
            break;
          case 5:
            self.session_states = {};
            for (i = m = 0, ref1 = d.object() - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; i = 0 <= ref1 ? ++m : --m) {
              tag = SessionTag.decode(d);
              self.session_states[tag] = {
                idx: i,
                tag: tag,
                state: SessionState.decode(d)
              };
            }
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_integer(self.version);
      TypeUtil.assert_is_instance(SessionTag, self.session_tag);
      TypeUtil.assert_is_instance(IdentityKeyPair, self.local_identity);
      TypeUtil.assert_is_instance(IdentityKey, self.remote_identity);
      TypeUtil.assert_is_instance(Object, self.session_states);
      return self;
    };

    return Session;

  })();

  SessionState = __webpack_require__(34);

}).call(this);


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, CipherKey, ClassUtil, DontCallConstructor, MacKey, MessageKeys, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  MacKey = __webpack_require__(16);

  CipherKey = __webpack_require__(20);

  module.exports = MessageKeys = (function() {
    function MessageKeys() {
      throw new DontCallConstructor(this);
    }

    MessageKeys["new"] = function(cipher_key, mac_key, counter) {
      var mk;
      TypeUtil.assert_is_instance(CipherKey, cipher_key);
      TypeUtil.assert_is_instance(MacKey, mac_key);
      TypeUtil.assert_is_integer(counter);
      mk = ClassUtil.new_instance(MessageKeys);
      mk.cipher_key = cipher_key;
      mk.mac_key = mac_key;
      mk.counter = counter;
      return mk;
    };

    MessageKeys.prototype._counter_as_nonce = function() {
      var nonce;
      nonce = new ArrayBuffer(8);
      new DataView(nonce).setUint32(0, this.counter);
      return new Uint8Array(nonce);
    };

    MessageKeys.prototype.encrypt = function(plaintext) {
      return this.cipher_key.encrypt(plaintext, this._counter_as_nonce());
    };

    MessageKeys.prototype.decrypt = function(ciphertext) {
      return this.cipher_key.decrypt(ciphertext, this._counter_as_nonce());
    };

    MessageKeys.prototype.encode = function(e) {
      e.object(3);
      e.u8(0);
      this.cipher_key.encode(e);
      e.u8(1);
      this.mac_key.encode(e);
      e.u8(2);
      return e.u32(this.counter);
    };

    MessageKeys.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(MessageKeys);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.cipher_key = CipherKey.decode(d);
            break;
          case 1:
            self.mac_key = MacKey.decode(d);
            break;
          case 2:
            self.counter = d.u32();
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(CipherKey, self.cipher_key);
      TypeUtil.assert_is_instance(MacKey, self.mac_key);
      TypeUtil.assert_is_integer(self.counter);
      return self;
    };

    return MessageKeys;

  })();

}).call(this);


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var TypeUtil;

  TypeUtil = __webpack_require__(1);

  module.exports = (function() {
    return {

      /*
      Concatenates array buffers (usually 8-bit unsigned).
       */
      concatenate_array_buffers: function(buffers) {
        TypeUtil.assert_is_instance(Array, buffers);
        return buffers.reduce(function(a, b) {
          var buf;
          buf = new a.constructor(a.byteLength + b.byteLength);
          buf.set(a, 0);
          buf.set(b, a.byteLength);
          return buf;
        });
      },
      array_buffer_to_string: function(buffer) {
        return String.fromCharCode.apply(null, buffer);
      },

      /*
      @see https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String?hl=en
       */
      string_to_array_buffer: function(str) {
        var array_buffer, bufView, i, strLen;
        array_buffer = new ArrayBuffer(str.length * 2);
        bufView = new Uint16Array(array_buffer);
        i = 0;
        strLen = str.length;
        while (i < strLen) {
          bufView[i] = str.charCodeAt(i);
          i++;
        }
        return array_buffer;
      },
      string_to_byte_array: function(string) {
        var byte_array, index;
        byte_array = [];
        for (index in string) {
          byte_array.push(string.charCodeAt(index));
        }
        return byte_array;
      },
      string_to_hex: function(input) {
        var c, i, str, tmp_len;
        str = '';
        i = 0;
        tmp_len = input.length;
        c = void 0;
        while (i < tmp_len) {
          c = input.charCodeAt(i);
          str += c.toString(16);
          i += 1;
        }
        return str;
      },
      byte_array_to_hex: function(bytes) {
        var hex, i;
        hex = [];
        i = 0;
        while (i < bytes.length) {
          hex.push((bytes[i] >>> 4).toString(16));
          hex.push((bytes[i] & 0xF).toString(16));
          i++;
        }
        return hex.join('');
      },
      hex_to_byte_array: function(hex) {
        var bytes, c;
        bytes = [];
        c = 0;
        while (c < hex.length) {
          bytes.push(parseInt(hex.substr(c, 2), 16));
          c += 2;
        }
        return bytes;
      },
      byte_array_to_bit_array: function(byte_array) {
        var bit_array_to_partial_word, i, out, tmp;
        bit_array_to_partial_word = function(len, x, _end) {
          if (len === 32) {
            return x;
          }
          return (_end ? x | 0 : x << 32 - len) + len * 0x10000000000;
        };
        out = [];
        i = void 0;
        tmp = 0;
        i = 0;
        while (i < byte_array.length) {
          tmp = tmp << 8 | byte_array[i];
          if ((i & 3) === 3) {
            out.push(tmp);
            tmp = 0;
          }
          i++;
        }
        if (i & 3) {
          out.push(bit_array_to_partial_word(8 * (i & 3), tmp));
        }
        return out;
      }
    };
  })();

}).call(this);


/***/ },
/* 30 */
/***/ function(module, exports) {

// Generated by CoffeeScript 1.11.1
(function() {
  var BaseError;

  module.exports = BaseError = (function() {
    function BaseError(message) {
      this.name = this.constructor.name;
      this.message = message;
      this.stack = (new Error).stack;
    }

    BaseError.prototype = new Error;

    BaseError.prototype.constructor = BaseError;

    return BaseError;

  })();

}).call(this);


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ChainKey, CipherMessage, ClassUtil, DecryptError, DontCallConstructor, Envelope, MessageKeys, ProteusError, PublicKey, RecvChain, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  PublicKey = __webpack_require__(4);

  ProteusError = __webpack_require__(6);

  DecryptError = __webpack_require__(11);

  Envelope = __webpack_require__(13);

  CipherMessage = __webpack_require__(8);

  MessageKeys = __webpack_require__(28);

  ChainKey = __webpack_require__(9);

  module.exports = RecvChain = (function() {
    RecvChain.MAX_COUNTER_GAP = 1000;

    function RecvChain() {
      throw new DontCallConstructor(this);
    }

    RecvChain["new"] = function(chain_key, public_key) {
      var rc;
      TypeUtil.assert_is_instance(ChainKey, chain_key);
      TypeUtil.assert_is_instance(PublicKey, public_key);
      rc = ClassUtil.new_instance(RecvChain);
      rc.chain_key = chain_key;
      rc.ratchet_key = public_key;
      rc.message_keys = [];
      return rc;
    };

    RecvChain.prototype.try_message_keys = function(envelope, msg) {
      var idx, mk;
      TypeUtil.assert_is_instance(Envelope, envelope);
      TypeUtil.assert_is_instance(CipherMessage, msg);
      if (this.message_keys[0] && this.message_keys[0].counter > msg.counter) {
        throw new DecryptError.OutdatedMessage;
      }
      idx = this.message_keys.findIndex(function(mk) {
        return mk.counter === msg.counter;
      });
      if (idx === -1) {
        throw new DecryptError.DuplicateMessage;
      }
      mk = this.message_keys.splice(idx, 1)[0];
      if (!envelope.verify(mk.mac_key)) {
        throw new DecryptError.InvalidSignature;
      }
      return mk.decrypt(msg.cipher_text);
    };

    RecvChain.prototype.stage_message_keys = function(msg) {
      var _, chk, i, keys, mk, num, ref;
      TypeUtil.assert_is_instance(CipherMessage, msg);
      num = msg.counter - this.chain_key.idx;
      if (num > RecvChain.MAX_COUNTER_GAP) {
        throw new DecryptError.TooDistantFuture;
      }
      keys = [];
      chk = this.chain_key;
      for (_ = i = 0, ref = num - 1; 0 <= ref ? i <= ref : i >= ref; _ = 0 <= ref ? ++i : --i) {
        keys.push(chk.message_keys());
        chk = chk.next();
      }
      mk = chk.message_keys();
      return [chk, mk, keys];
    };

    RecvChain.prototype.commit_message_keys = function(keys) {
      var _, excess, i, ref;
      TypeUtil.assert_is_instance(Array, keys);
      keys.map(function(k) {
        return TypeUtil.assert_is_instance(MessageKeys, k);
      });
      if (keys.length > RecvChain.MAX_COUNTER_GAP) {
        throw new ProteusError('More keys than MAX_COUNTER_GAP');
      }
      excess = this.message_keys.length + keys.length - RecvChain.MAX_COUNTER_GAP;
      for (_ = i = 0, ref = excess - 1; 0 <= ref ? i <= ref : i >= ref; _ = 0 <= ref ? ++i : --i) {
        this.message_keys.shift();
      }
      keys.map((function(_this) {
        return function(k) {
          return _this.message_keys.push(k);
        };
      })(this));
      if (keys.length > RecvChain.MAX_COUNTER_GAP) {
        throw new ProteusError('Skipped keys greater than MAX_COUNTER_GAP');
      }
    };

    RecvChain.prototype.encode = function(e) {
      e.object(3);
      e.u8(0);
      this.chain_key.encode(e);
      e.u8(1);
      this.ratchet_key.encode(e);
      e.u8(2);
      e.array(this.message_keys.length);
      return this.message_keys.map(function(k) {
        return k.encode(e);
      });
    };

    RecvChain.decode = function(d) {
      var i, len, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(RecvChain);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.chain_key = ChainKey.decode(d);
            break;
          case 1:
            self.ratchet_key = PublicKey.decode(d);
            break;
          case 2:
            self.message_keys = [];
            len = d.array();
            while (len--) {
              self.message_keys.push(MessageKeys.decode(d));
            }
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(ChainKey, self.chain_key);
      TypeUtil.assert_is_instance(PublicKey, self.ratchet_key);
      TypeUtil.assert_is_instance(Array, self.message_keys);
      return self;
    };

    return RecvChain;

  })();

}).call(this);


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ChainKey, CipherKey, ClassUtil, DerivedSecrets, DontCallConstructor, KeyPair, PublicKey, RootKey, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  PublicKey = __webpack_require__(4);

  KeyPair = __webpack_require__(5);

  DerivedSecrets = __webpack_require__(21);

  CipherKey = __webpack_require__(20);

  ChainKey = __webpack_require__(9);

  module.exports = RootKey = (function() {
    function RootKey() {
      throw new DontCallConstructor(this);
    }


    /*
    @param key [Proteus.derived.CipherKey] Cipher key generated by derived secrets
     */

    RootKey.from_cipher_key = function(cipher_key) {
      var rk;
      TypeUtil.assert_is_instance(CipherKey, cipher_key);
      rk = ClassUtil.new_instance(RootKey);
      rk.key = cipher_key;
      return rk;
    };


    /*
    @param ours [KeyPair] Our key pair
    @param theirs [PublicKey] Their public key
     */

    RootKey.prototype.dh_ratchet = function(ours, theirs) {
      var dsecs, secret;
      TypeUtil.assert_is_instance(KeyPair, ours);
      TypeUtil.assert_is_instance(PublicKey, theirs);
      secret = ours.secret_key.shared_secret(theirs);
      dsecs = DerivedSecrets.kdf(secret, this.key.key, 'dh_ratchet');
      return [RootKey.from_cipher_key(dsecs.cipher_key), ChainKey.from_mac_key(dsecs.mac_key, 0)];
    };

    RootKey.prototype.encode = function(e) {
      e.object(1);
      e.u8(0);
      return this.key.encode(e);
    };

    RootKey.decode = function(d) {
      var cipher_key, i, nprops, ref;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      cipher_key = null;
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            cipher_key = CipherKey.decode(d);
            break;
          default:
            d.skip();
        }
      }
      return RootKey.from_cipher_key(cipher_key);
    };

    return RootKey;

  })();

}).call(this);


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var CBOR, ChainKey, ClassUtil, DontCallConstructor, KeyPair, SendChain, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  KeyPair = __webpack_require__(5);

  ChainKey = __webpack_require__(9);

  module.exports = SendChain = (function() {
    function SendChain() {
      throw new DontCallConstructor(this);
    }

    SendChain["new"] = function(chain_key, keypair) {
      var sc;
      TypeUtil.assert_is_instance(ChainKey, chain_key);
      TypeUtil.assert_is_instance(KeyPair, keypair);
      sc = ClassUtil.new_instance(SendChain);
      sc.chain_key = chain_key;
      sc.ratchet_key = keypair;
      return sc;
    };

    SendChain.prototype.encode = function(e) {
      e.object(2);
      e.u8(0);
      this.chain_key.encode(e);
      e.u8(1);
      return this.ratchet_key.encode(e);
    };

    SendChain.decode = function(d) {
      var i, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(SendChain);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.chain_key = ChainKey.decode(d);
            break;
          case 1:
            self.ratchet_key = KeyPair.decode(d);
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(ChainKey, self.chain_key);
      TypeUtil.assert_is_instance(KeyPair, self.ratchet_key);
      return self;
    };

    return SendChain;

  })();

}).call(this);


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var ArrayUtil, CBOR, ChainKey, CipherMessage, ClassUtil, DecryptError, DerivedSecrets, DontCallConstructor, Envelope, IdentityKey, IdentityKeyPair, KeyPair, PreKeyBundle, PreKeyMessage, PublicKey, RecvChain, RootKey, SendChain, Session, SessionState, SessionTag, TypeUtil;

  CBOR = __webpack_require__(3);

  DontCallConstructor = __webpack_require__(0);

  ClassUtil = __webpack_require__(2);

  TypeUtil = __webpack_require__(1);

  ArrayUtil = __webpack_require__(29);

  DecryptError = __webpack_require__(11);

  DerivedSecrets = __webpack_require__(21);

  IdentityKeyPair = __webpack_require__(12);

  IdentityKey = __webpack_require__(7);

  PreKeyBundle = __webpack_require__(18);

  PublicKey = __webpack_require__(4);

  KeyPair = __webpack_require__(5);

  Envelope = __webpack_require__(13);

  CipherMessage = __webpack_require__(8);

  PreKeyMessage = __webpack_require__(15);

  SessionTag = __webpack_require__(22);

  RecvChain = __webpack_require__(31);

  SendChain = __webpack_require__(33);

  ChainKey = __webpack_require__(9);

  RootKey = __webpack_require__(32);

  Session = __webpack_require__(27);

  module.exports = SessionState = (function() {
    function SessionState() {
      this.recv_chains = null;
      this.send_chain = null;
      this.root_key = null;
      this.prev_counter = null;
      throw new DontCallConstructor(this);
    }

    SessionState.init_as_alice = function(alice_identity_pair, alice_base, bob_pkbundle) {
      var chainkey, chk, dsecs, master_key, recv_chains, ref, rok, rootkey, send_chain, send_ratchet, state;
      TypeUtil.assert_is_instance(IdentityKeyPair, alice_identity_pair);
      TypeUtil.assert_is_instance(KeyPair, alice_base);
      TypeUtil.assert_is_instance(PreKeyBundle, bob_pkbundle);
      master_key = ArrayUtil.concatenate_array_buffers([alice_identity_pair.secret_key.shared_secret(bob_pkbundle.public_key), alice_base.secret_key.shared_secret(bob_pkbundle.identity_key.public_key), alice_base.secret_key.shared_secret(bob_pkbundle.public_key)]);
      dsecs = DerivedSecrets.kdf_without_salt(master_key, "handshake");
      rootkey = RootKey.from_cipher_key(dsecs.cipher_key);
      chainkey = ChainKey.from_mac_key(dsecs.mac_key, 0);
      recv_chains = [RecvChain["new"](chainkey, bob_pkbundle.public_key)];
      send_ratchet = KeyPair["new"]();
      ref = rootkey.dh_ratchet(send_ratchet, bob_pkbundle.public_key), rok = ref[0], chk = ref[1];
      send_chain = SendChain["new"](chk, send_ratchet);
      state = ClassUtil.new_instance(SessionState);
      state.recv_chains = recv_chains;
      state.send_chain = send_chain;
      state.root_key = rok;
      state.prev_counter = 0;
      return state;
    };

    SessionState.init_as_bob = function(bob_ident, bob_prekey, alice_ident, alice_base) {
      var chainkey, dsecs, master_key, rootkey, send_chain, state;
      TypeUtil.assert_is_instance(IdentityKeyPair, bob_ident);
      TypeUtil.assert_is_instance(KeyPair, bob_prekey);
      TypeUtil.assert_is_instance(IdentityKey, alice_ident);
      TypeUtil.assert_is_instance(PublicKey, alice_base);
      master_key = ArrayUtil.concatenate_array_buffers([bob_prekey.secret_key.shared_secret(alice_ident.public_key), bob_ident.secret_key.shared_secret(alice_base), bob_prekey.secret_key.shared_secret(alice_base)]);
      dsecs = DerivedSecrets.kdf_without_salt(master_key, "handshake");
      rootkey = RootKey.from_cipher_key(dsecs.cipher_key);
      chainkey = ChainKey.from_mac_key(dsecs.mac_key, 0);
      send_chain = SendChain["new"](chainkey, bob_prekey);
      state = ClassUtil.new_instance(SessionState);
      state.recv_chains = [];
      state.send_chain = send_chain;
      state.root_key = rootkey;
      state.prev_counter = 0;
      return state;
    };

    SessionState.prototype.ratchet = function(ratchet_key) {
      var new_ratchet, recv_chain, recv_chain_key, recv_root_key, ref, ref1, send_chain, send_chain_key, send_root_key;
      new_ratchet = KeyPair["new"]();
      ref = this.root_key.dh_ratchet(this.send_chain.ratchet_key, ratchet_key), recv_root_key = ref[0], recv_chain_key = ref[1];
      ref1 = recv_root_key.dh_ratchet(new_ratchet, ratchet_key), send_root_key = ref1[0], send_chain_key = ref1[1];
      recv_chain = RecvChain["new"](recv_chain_key, ratchet_key);
      send_chain = SendChain["new"](send_chain_key, new_ratchet);
      this.root_key = send_root_key;
      this.prev_counter = this.send_chain.chain_key.idx;
      this.send_chain = send_chain;
      this.recv_chains.unshift(recv_chain);
      if (this.recv_chains.length > Session.MAX_RECV_CHAINS) {
        this.recv_chains = this.recv_chains.slice(0, Session.MAX_RECV_CHAINS);
      }
    };


    /*
    @param identity_key [Proteus.keys.IdentityKey] Public identity key of the local identity key pair
    @param pending [] Pending pre-key
    @param tag [Proteus.message.SessionTag] Session tag
    @param plaintext [String] The plaintext to encrypt
    
    @return [Proteus.message.Envelope]
     */

    SessionState.prototype.encrypt = function(identity_key, pending, tag, plaintext) {
      var env, message, msgkeys;
      if (pending) {
        TypeUtil.assert_is_integer(pending[0]);
        TypeUtil.assert_is_instance(PublicKey, pending[1]);
      }
      TypeUtil.assert_is_instance(IdentityKey, identity_key);
      TypeUtil.assert_is_instance(SessionTag, tag);
      msgkeys = this.send_chain.chain_key.message_keys();
      message = CipherMessage["new"](tag, this.send_chain.chain_key.idx, this.prev_counter, this.send_chain.ratchet_key.public_key, msgkeys.encrypt(plaintext));
      if (pending) {
        message = PreKeyMessage["new"](pending[0], pending[1], identity_key, message);
      }
      env = Envelope["new"](msgkeys.mac_key, message);
      this.send_chain.chain_key = this.send_chain.chain_key.next();
      return env;
    };

    SessionState.prototype.decrypt = function(envelope, msg) {
      var chk, idx, mk, mks, plain, rc, ref;
      TypeUtil.assert_is_instance(Envelope, envelope);
      TypeUtil.assert_is_instance(CipherMessage, msg);
      idx = this.recv_chains.findIndex(function(c) {
        return c.ratchet_key.fingerprint() === msg.ratchet_key.fingerprint();
      });
      if (idx === -1) {
        this.ratchet(msg.ratchet_key);
        idx = 0;
      }
      rc = this.recv_chains[idx];
      switch (false) {
        case !(msg.counter < rc.chain_key.idx):
          return rc.try_message_keys(envelope, msg);
        case msg.counter !== rc.chain_key.idx:
          mks = rc.chain_key.message_keys();
          if (!envelope.verify(mks.mac_key)) {
            throw new DecryptError.InvalidSignature;
          }
          plain = mks.decrypt(msg.cipher_text);
          rc.chain_key = rc.chain_key.next();
          return plain;
        case !(msg.counter > rc.chain_key.idx):
          ref = rc.stage_message_keys(msg), chk = ref[0], mk = ref[1], mks = ref[2];
          if (!envelope.verify(mk.mac_key)) {
            throw new DecryptError.InvalidSignature;
          }
          plain = mk.decrypt(msg.cipher_text);
          rc.chain_key = chk.next();
          rc.commit_message_keys(mks);
          return plain;
      }
    };

    SessionState.prototype.serialise = function() {
      var e;
      e = new CBOR.Encoder();
      this.encode(e);
      return e.get_buffer();
    };

    SessionState.deserialise = function(buf) {
      TypeUtil.assert_is_instance(ArrayBuffer, buf);
      return SessionState.decode(new CBOR.Decoder(buf));
    };

    SessionState.prototype.encode = function(e) {
      e.object(4);
      e.u8(0);
      e.array(this.recv_chains.length);
      this.recv_chains.map(function(rch) {
        return rch.encode(e);
      });
      e.u8(1);
      this.send_chain.encode(e);
      e.u8(2);
      this.root_key.encode(e);
      e.u8(3);
      return e.u32(this.prev_counter);
    };

    SessionState.decode = function(d) {
      var i, len, nprops, ref, self;
      TypeUtil.assert_is_instance(CBOR.Decoder, d);
      self = ClassUtil.new_instance(SessionState);
      nprops = d.object();
      for (i = 0, ref = nprops - 1; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
        switch (d.u8()) {
          case 0:
            self.recv_chains = [];
            len = d.array();
            while (len--) {
              self.recv_chains.push(RecvChain.decode(d));
            }
            break;
          case 1:
            self.send_chain = SendChain.decode(d);
            break;
          case 2:
            self.root_key = RootKey.decode(d);
            break;
          case 3:
            self.prev_counter = d.u32();
            break;
          default:
            d.skip();
        }
      }
      TypeUtil.assert_is_instance(Array, self.recv_chains);
      TypeUtil.assert_is_instance(SendChain, self.send_chain);
      TypeUtil.assert_is_instance(RootKey, self.root_key);
      TypeUtil.assert_is_integer(self.prev_counter);
      return self;
    };

    return SessionState;

  })();

}).call(this);


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var ArrayUtil, TypeUtil;

  TypeUtil = __webpack_require__(1);

  ArrayUtil = __webpack_require__(29);

  module.exports = (function() {
    return {

      /*
      HMAC-based Key Derivation Function
      
      @param salt [Uint8Array, String] Salt
      @param input [Uint8Array, String] Initial Keying Material (IKM)
      @param info [Uint8Array, String] Key Derivation Data (Info)
      @param length [Integer] Length of the derived key in bytes (L)
      
      @return [Uint8Array] Output Keying Material (OKM)
       */
      hkdf: function(salt, input, info, length) {
        var HASH_LEN, convert_type, expand, extract, key, salt_to_key;
        convert_type = function(value) {
          if (typeof value === 'string') {
            return sodium.from_string(value);
          }
          TypeUtil.assert_is_instance(Uint8Array, value);
          return value;
        };
        salt = convert_type(salt);
        input = convert_type(input);
        info = convert_type(info);
        TypeUtil.assert_is_integer(length);
        HASH_LEN = 32;
        salt_to_key = function(salt) {
          var key, keybytes;
          keybytes = sodium.crypto_auth_hmacsha256_KEYBYTES;
          if (salt.length > keybytes) {
            return sodium.crypto_hash_sha256(salt);
          }
          key = new Uint8Array(keybytes);
          key.set(salt);
          return key;
        };
        extract = function(salt, input) {
          return sodium.crypto_auth_hmacsha256(input, salt_to_key(salt));
        };
        expand = function(tag, info, length) {
          var buf, hmac, i, j, num_blocks, ref, result;
          num_blocks = Math.ceil(length / HASH_LEN);
          hmac = new Uint8Array(0);
          result = new Uint8Array(0);
          for (i = j = 0, ref = num_blocks - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            buf = ArrayUtil.concatenate_array_buffers([hmac, info, new Uint8Array([i + 1])]);
            hmac = sodium.crypto_auth_hmacsha256(buf, tag);
            result = ArrayUtil.concatenate_array_buffers([result, hmac]);
          }
          return new Uint8Array(result.buffer.slice(0, length));
        };
        key = extract(salt, input);
        return expand(key, info, length);
      }
    };
  })();

}).call(this);


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  module.exports = (function() {
    var crypto;
    crypto = (typeof window !== 'undefined') && (window.crypto || window.msCrypto);
    if (crypto) {
      return (function() {
        return {
          random_bytes: function(len) {
            var buffer, buffer_view;
            buffer = new ArrayBuffer(len);
            buffer_view = new Uint8Array(buffer);
            return crypto.getRandomValues(buffer_view);
          }
        };
      })();
    } else {
      crypto = __webpack_require__(39);
      return (function() {
        return {
          random_bytes: function(len) {
            return new Uint8Array(crypto.randomBytes(len));
          }
        };
      })();
    }
  })();

}).call(this);


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var DecodeError, Decoder, Types,
    slice = [].slice;

  DecodeError = __webpack_require__(23);

  Types = __webpack_require__(24);

  module.exports = Decoder = (function() {
    Decoder.prototype.DEFAULT_CONFIG = {
      max_array_length: 1000,
      max_bytes_length: 5242880,
      max_text_length: 5242880,
      max_object_size: 1000,
      max_nesting: 16
    };

    function Decoder(buffer, config) {
      this.buffer = buffer;
      this.config = config != null ? config : Decoder.prototype.DEFAULT_CONFIG;
      this.view = new DataView(this.buffer);
      return this;
    }

    Decoder._check_overflow = function(x, overflow) {
      if (x > overflow) {
        throw new DecodeError(DecodeError.prototype.INT_OVERFLOW);
      }
      return x;
    };

    Decoder.prototype._advance = function(bytes) {
      return this.view = new DataView(this.buffer, this.view.byteOffset + bytes);
    };

    Decoder.prototype._available = function() {
      return this.view.byteLength;
    };

    Decoder.prototype._read = function(bytes, closure) {
      var value;
      if (this._available < bytes) {
        throw new DecodeError(DecodeError.prototype.UNEXPECTED_EOF);
      }
      value = closure();
      this._advance(bytes);
      return value;
    };


    /*
     * reader-like interface for @buffer
     */

    Decoder.prototype._u8 = function() {
      return this._read(1, (function(_this) {
        return function() {
          return _this.view.getUint8(0);
        };
      })(this));
    };

    Decoder.prototype._u16 = function() {
      return this._read(2, (function(_this) {
        return function() {
          return _this.view.getUint16(0);
        };
      })(this));
    };

    Decoder.prototype._u32 = function() {
      return this._read(4, (function(_this) {
        return function() {
          return _this.view.getUint32(0);
        };
      })(this));
    };

    Decoder.prototype._u64 = function() {
      var r64;
      r64 = (function(_this) {
        return function(x) {
          return (_this.view.getUint32(0) * Math.pow(2, 32)) + _this.view.getUint32(4);
        };
      })(this);
      return this._read(8, r64);
    };

    Decoder.prototype._f32 = function() {
      return this._read(4, (function(_this) {
        return function() {
          return _this.view.getFloat32(0);
        };
      })(this));
    };

    Decoder.prototype._f64 = function() {
      return this._read(8, (function(_this) {
        return function() {
          return _this.view.getFloat64(0);
        };
      })(this));
    };

    Decoder.prototype._read_length = function(minor) {
      if (0 <= minor && minor <= 23) {
        return minor;
      }
      switch (minor) {
        case 24:
          return this._u8();
        case 25:
          return this._u16();
        case 26:
          return this._u32();
        case 27:
          return Decoder._check_overflow(this._u64(), Number.MAX_SAFE_INTEGER);
      }
      throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE);
    };

    Decoder.prototype._bytes = function(minor, max_len) {
      var len;
      len = this._read_length(minor);
      if (len > max_len) {
        throw new DecodeError(DecodeError.prototype.TOO_LONG);
      }
      return this._read(len, (function(_this) {
        return function() {
          return _this.buffer.slice(_this.view.byteOffset, _this.view.byteOffset + len);
        };
      })(this));
    };

    Decoder.prototype._read_type_info = function() {
      var major, minor, type;
      type = this._u8();
      major = (type & 0xE0) >> 5;
      minor = type & 0x1F;
      switch (major) {
        case 0:
          type = (function() {
            if (0 <= minor && minor <= 24) {
              return Types.prototype.UINT8;
            } else {
              switch (minor) {
                case 25:
                  return Types.prototype.UINT16;
                case 26:
                  return Types.prototype.UINT32;
                case 27:
                  return Types.prototype.UINT64;
                default:
                  throw new DecodeError(DecodeError.prototype.INVALID_TYPE);
              }
            }
          })();
          return [type, minor];
        case 1:
          type = (function() {
            if (0 <= minor && minor <= 24) {
              return Types.prototype.INT8;
            } else {
              switch (minor) {
                case 25:
                  return Types.prototype.INT16;
                case 26:
                  return Types.prototype.INT32;
                case 27:
                  return Types.prototype.INT64;
                default:
                  throw new DecodeError(DecodeError.prototype.INVALID_TYPE);
              }
            }
          })();
          return [type, minor];
        case 2:
          return [Types.prototype.BYTES, minor];
        case 3:
          return [Types.prototype.TEXT, minor];
        case 4:
          return [Types.prototype.ARRAY, minor];
        case 5:
          return [Types.prototype.OBJECT, minor];
        case 7:
          switch (minor) {
            case 20:
            case 21:
              return [Types.prototype.BOOL, minor];
            case 22:
              return [Types.prototype.NULL, minor];
            case 25:
              return [Types.prototype.FLOAT16, minor];
            case 26:
              return [Types.prototype.FLOAT32, minor];
            case 27:
              return [Types.prototype.FLOAT64, minor];
            case 31:
              return [Types.prototype.BREAK, minor];
          }
      }
      throw new DecodeError(DecodeError.prototype.INVALID_TYPE);
    };

    Decoder.prototype._type_info_with_assert = function(expected) {
      var minor, ref, type;
      ref = this._read_type_info(), type = ref[0], minor = ref[1];
      if (!Array.isArray(expected)) {
        expected = [expected];
      }
      if (!expected.some(function(e) {
        return type === e;
      })) {
        throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE, [type, minor]);
      }
      return [type, minor];
    };

    Decoder.prototype._read_unsigned = function(type, minor) {
      switch (type) {
        case Types.prototype.UINT8:
          if (minor <= 23) {
            return minor;
          }
          return this._u8();
        case Types.prototype.UINT16:
          return this._u16();
        case Types.prototype.UINT32:
          return this._u32();
        case Types.prototype.UINT64:
          return this._u64();
      }
      throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE, [type, minor]);
    };

    Decoder.prototype._read_signed = function(overflow, type, minor) {
      switch (type) {
        case Types.prototype.INT8:
          if (minor <= 23) {
            return -1 - minor;
          }
          return -1 - Decoder._check_overflow(this._u8(), overflow);
        case Types.prototype.INT16:
          return -1 - Decoder._check_overflow(this._u16(), overflow);
        case Types.prototype.INT32:
          return -1 - Decoder._check_overflow(this._u32(), overflow);
        case Types.prototype.INT64:
          return -1 - Decoder._check_overflow(this._u64(), overflow);
        case Types.prototype.UINT8:
        case Types.prototype.UINT16:
        case Types.prototype.UINT32:
        case Types.prototype.UINT64:
          return Decoder._check_overflow(this._read_unsigned(type, minor), overflow);
      }
      throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE, [type, minor]);
    };


    /*
     * public API
     */

    Decoder.prototype.u8 = function() {
      return this._read_unsigned.apply(this, this._type_info_with_assert([Types.prototype.UINT8]));
    };

    Decoder.prototype.u16 = function() {
      return this._read_unsigned.apply(this, this._type_info_with_assert([Types.prototype.UINT8, Types.prototype.UINT16]));
    };

    Decoder.prototype.u32 = function() {
      return this._read_unsigned.apply(this, this._type_info_with_assert([Types.prototype.UINT8, Types.prototype.UINT16, Types.prototype.UINT32]));
    };

    Decoder.prototype.u64 = function() {
      return this._read_unsigned.apply(this, this._type_info_with_assert([Types.prototype.UINT8, Types.prototype.UINT16, Types.prototype.UINT32, Types.prototype.UINT64]));
    };

    Decoder.prototype.i8 = function() {
      return this._read_signed.apply(this, [127].concat(slice.call(this._type_info_with_assert([Types.prototype.INT8, Types.prototype.UINT8]))));
    };

    Decoder.prototype.i16 = function() {
      return this._read_signed.apply(this, [32767].concat(slice.call(this._type_info_with_assert([Types.prototype.INT8, Types.prototype.INT16, Types.prototype.UINT8, Types.prototype.UINT16]))));
    };

    Decoder.prototype.i32 = function() {
      return this._read_signed.apply(this, [2147483647].concat(slice.call(this._type_info_with_assert([Types.prototype.INT8, Types.prototype.INT16, Types.prototype.INT32, Types.prototype.UINT8, Types.prototype.UINT16, Types.prototype.UINT32]))));
    };

    Decoder.prototype.i64 = function() {
      return this._read_signed.apply(this, [Number.MAX_SAFE_INTEGER].concat(slice.call(this._type_info_with_assert([Types.prototype.INT8, Types.prototype.INT16, Types.prototype.INT32, Types.prototype.INT64, Types.prototype.UINT8, Types.prototype.UINT16, Types.prototype.UINT32, Types.prototype.UINT64]))));
    };

    Decoder.prototype.unsigned = function() {
      return this.u64();
    };

    Decoder.prototype.int = function() {
      return this.i64();
    };

    Decoder.prototype.f16 = function() {
      var exp, half, ldexp, mant, val;
      this._type_info_with_assert(Types.prototype.FLOAT16);
      half = this._u16();
      exp = half >> 10 & 0x1F;
      mant = half & 0x3FF;
      ldexp = function(x, exp) {
        return x * Math.pow(2, exp);
      };
      val = (function() {
        switch (exp) {
          case 0:
            return ldexp(mant, -24);
          case 31:
            if (mant === 0) {
              return Number.POSITIVE_INFINITY;
            } else {
              return Number.NaN;
            }
            break;
          default:
            return ldexp(mant + 1024, exp - 25);
        }
      })();
      if (half & 0x8000) {
        return -val;
      }
      return val;
    };

    Decoder.prototype.f32 = function() {
      this._type_info_with_assert(Types.prototype.FLOAT32);
      return this._f32();
    };

    Decoder.prototype.f64 = function() {
      this._type_info_with_assert(Types.prototype.FLOAT64);
      return this._f64();
    };

    Decoder.prototype.bool = function() {
      var _, minor, ref;
      ref = this._type_info_with_assert(Types.prototype.BOOL), _ = ref[0], minor = ref[1];
      switch (minor) {
        case 20:
          return false;
        case 21:
          return true;
        default:
          throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE);
      }
    };

    Decoder.prototype.bytes = function() {
      var _, minor, ref;
      ref = this._type_info_with_assert(Types.prototype.BYTES), _ = ref[0], minor = ref[1];
      if (minor === 31) {
        throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE);
      }
      return this._bytes(minor, this.config['max_bytes_length']);
    };

    Decoder.prototype.text = function() {
      var _, buf, minor, ref, utf8;
      ref = this._type_info_with_assert(Types.prototype.TEXT), _ = ref[0], minor = ref[1];
      if (minor === 31) {
        throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE);
      }
      buf = this._bytes(minor, this.config['max_text_length']);
      utf8 = String.fromCharCode.apply(String, new Uint8Array(buf));
      return decodeURIComponent(escape(utf8));
    };

    Decoder.prototype.optional = function(closure) {
      var error;
      try {
        return closure();
      } catch (error1) {
        error = error1;
        if (error instanceof DecodeError && error.extra[0] === Types.prototype.NULL) {
          return null;
        }
        throw error;
      }
    };

    Decoder.prototype.array = function() {
      var _, len, minor, ref;
      ref = this._type_info_with_assert(Types.prototype.ARRAY), _ = ref[0], minor = ref[1];
      if (minor === 31) {
        throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE);
      }
      len = this._read_length(minor);
      if (len > this.config['max_array_length']) {
        throw new DecodeError(DecodeError.prototype.TOO_LONG);
      }
      return len;
    };

    Decoder.prototype.object = function() {
      var _, len, minor, ref;
      ref = this._type_info_with_assert(Types.prototype.OBJECT), _ = ref[0], minor = ref[1];
      if (minor === 31) {
        throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE);
      }
      len = this._read_length(minor);
      if (len > this.config['max_object_size']) {
        throw new DecodeError(DecodeError.prototype.TOO_LONG);
      }
      return len;
    };

    Decoder.prototype._skip_until_break = function(type) {
      var len, minor, ref, t;
      while (true) {
        ref = this._read_type_info(), t = ref[0], minor = ref[1];
        if (t === Types.prototype.BREAK) {
          return;
        }
        if (t !== type || minor === 31) {
          throw new DecodeError(DecodeError.prototype.UNEXPECTED_TYPE);
        }
        len = this._read_length(minor);
        this._advance(len);
      }
    };

    Decoder.prototype._skip_value = function(level) {
      var len, minor, ref, type;
      if (level === 0) {
        throw new DecodeError(DecodeError.prototype.TOO_NESTED);
      }
      ref = this._read_type_info(), type = ref[0], minor = ref[1];
      switch (type) {
        case Types.prototype.UINT8:
        case Types.prototype.UINT16:
        case Types.prototype.UINT32:
        case Types.prototype.UINT64:
        case Types.prototype.INT8:
        case Types.prototype.INT16:
        case Types.prototype.INT32:
        case Types.prototype.INT64:
          this._read_length(minor);
          return true;
        case Types.prototype.BOOL:
        case Types.prototype.NULL:
          return true;
        case Types.prototype.BREAK:
          return false;
        case Types.prototype.FLOAT16:
          this._advance(2);
          return true;
        case Types.prototype.FLOAT32:
          this._advance(4);
          return true;
        case Types.prototype.FLOAT64:
          this._advance(8);
          return true;
        case Types.prototype.BYTES:
        case Types.prototype.TEXT:
          if (minor === 31) {
            this._skip_until_break(type);
            return true;
          }
          len = this._read_length(minor);
          this._advance(len);
          return true;
        case Types.prototype.ARRAY:
        case Types.prototype.OBJECT:
          if (minor === 31) {
            while (this._skip_value(level - 1)) {}
            return true;
          }
          len = this._read_length(minor);
          while (len--) {
            this._skip_value(level - 1);
          }
          return true;
      }
    };

    Decoder.prototype.skip = function() {
      return this._skip_value(this.config['max_nesting']);
    };

    return Decoder;

  })();

}).call(this);


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  var DecodeError, Encoder, Types;

  DecodeError = __webpack_require__(23);

  Types = __webpack_require__(24);

  module.exports = Encoder = (function() {
    function Encoder() {
      this.buffer = new ArrayBuffer(4);
      this.view = new DataView(this.buffer);
      return this;
    }

    Encoder.prototype.get_buffer = function() {
      return this.buffer.slice(0, this.view.byteOffset);
    };

    Encoder.prototype._grow_buffer = function(need_nbytes) {
      var new_buf, new_len;
      new_len = Math.max(this.buffer.byteLength * 1.5, this.buffer.byteLength + need_nbytes);
      new_buf = new ArrayBuffer(new_len);
      new Uint8Array(new_buf).set(new Uint8Array(this.buffer));
      this.buffer = new_buf;
      return this.view = new DataView(this.buffer, this.view.byteOffset);
    };

    Encoder.prototype._ensure = function(bytes) {
      if (!(this.view.byteLength < bytes)) {
        return;
      }
      return this._grow_buffer(bytes);
    };

    Encoder.prototype._advance = function(bytes) {
      return this.view = new DataView(this.buffer, this.view.byteOffset + bytes);
    };

    Encoder.prototype._write = function(bytes, closure) {
      this._ensure(bytes);
      closure();
      return this._advance(bytes);
    };

    Encoder.prototype._write_type_and_len = function(type, len) {
      var major;
      major = (Types.major(type)) << 5;
      if (0 <= len && len <= 23) {
        return this._u8(major | len);
      } else if (24 <= len && len <= 255) {
        this._u8(major | 24);
        return this._u8(len);
      } else if (0x100 <= len && len <= 0xFFFF) {
        this._u8(major | 25);
        return this._u16(len);
      } else if (0x10000 <= len && len <= 0xFFFFFFFF) {
        this._u8(major | 26);
        return this._u32(len);
      } else if (len <= Number.MAX_SAFE_INTEGER) {
        this._u8(major | 27);
        return this._u64(len);
      } else {
        throw new RangeError('Invalid size for CBOR object');
      }
    };


    /*
     * writer-like interface over our ArrayBuffer
     */

    Encoder.prototype._u8 = function(x) {
      return this._write(1, (function(_this) {
        return function() {
          return _this.view.setUint8(0, x);
        };
      })(this));
    };

    Encoder.prototype._u16 = function(x) {
      return this._write(2, (function(_this) {
        return function() {
          return _this.view.setUint16(0, x);
        };
      })(this));
    };

    Encoder.prototype._u32 = function(x) {
      return this._write(4, (function(_this) {
        return function() {
          return _this.view.setUint32(0, x);
        };
      })(this));
    };

    Encoder.prototype._u64 = function(x) {
      var high, low, w64;
      low = x % Math.pow(2, 32);
      high = (x - low) / Math.pow(2, 32);
      w64 = (function(_this) {
        return function(x) {
          _this.view.setUint32(0, high);
          return _this.view.setUint32(4, low);
        };
      })(this);
      return this._write(8, w64, x);
    };

    Encoder.prototype._f32 = function(x) {
      return this._write(4, (function(_this) {
        return function() {
          return _this.view.setFloat32(0, x);
        };
      })(this));
    };

    Encoder.prototype._f64 = function(x) {
      return this._write(8, (function(_this) {
        return function() {
          return _this.view.setFloat64(0, x);
        };
      })(this));
    };

    Encoder.prototype._bytes = function(x) {
      var nbytes;
      nbytes = x.byteLength;
      this._ensure(nbytes);
      new Uint8Array(this.buffer, this.view.byteOffset).set(x);
      return this._advance(nbytes);
    };


    /*
     * public API
     */

    Encoder.prototype.u8 = function(x) {
      if (0 <= x && x <= 23) {
        return this._u8(x);
      } else if (24 <= x && x <= 255) {
        this._u8(24);
        return this._u8(x);
      } else {
        throw new RangeError('Invalid u8');
      }
    };

    Encoder.prototype.u16 = function(x) {
      if (0 <= x && x <= 23) {
        return this._u8(x);
      } else if (24 <= x && x <= 255) {
        this._u8(24);
        return this._u8(x);
      } else if (0x100 <= x && x <= 0xFFFF) {
        this._u8(25);
        return this._u16(x);
      } else {
        throw new RangeError('Invalid u16');
      }
    };

    Encoder.prototype.u32 = function(x) {
      if (0 <= x && x <= 23) {
        return this._u8(x);
      } else if (24 <= x && x <= 255) {
        this._u8(24);
        return this._u8(x);
      } else if (0x100 <= x && x <= 0xFFFF) {
        this._u8(25);
        return this._u16(x);
      } else if (0x10000 <= x && x <= 0xFFFFFFFF) {
        this._u8(26);
        return this._u32(x);
      } else {
        throw new RangeError('Invalid u32');
      }
    };

    Encoder.prototype.u64 = function(x) {
      if (0 <= x && x <= 23) {
        return this._u8(x);
      } else if (24 <= x && x <= 255) {
        this._u8(24);
        return this._u8(x);
      } else if (0x100 <= x && x <= 0xFFFF) {
        this._u8(25);
        return this._u16(x);
      } else if (0x10000 <= x && x <= 0xFFFFFFFF) {
        this._u8(26);
        return this._u32(x);
      } else if (x <= Number.MAX_SAFE_INTEGER) {
        this._u8(27);
        return this._u64(x);
      } else {
        throw new RangeError('Invalid unsigned integer');
      }
    };

    Encoder.prototype.i8 = function(x) {
      if (x >= 0) {
        return this._u8(x);
      }
      x = -1 - x;
      if (0 <= x && x <= 23) {
        return this._u8(0x20 | x);
      } else if (24 <= x && x <= 255) {
        this._u8(0x20 | 24);
        return this._u8(x);
      } else {
        throw new RangeError('Invalid i8');
      }
    };

    Encoder.prototype.i16 = function(x) {
      if (x >= 0) {
        return this._u16(x);
      }
      x = -1 - x;
      if (0 <= x && x <= 23) {
        return this._u8(0x20 | x);
      } else if (24 <= x && x <= 255) {
        this._u8(0x20 | 24);
        return this._u8(x);
      } else if (0x100 <= x && x <= 0xFFFF) {
        this._u8(0x20 | 25);
        return this._u16(x);
      } else {
        throw new RangeError('Invalid i16');
      }
    };

    Encoder.prototype.i32 = function(x) {
      if (x >= 0) {
        return this._u32(x);
      }
      x = -1 - x;
      if (0 <= x && x <= 23) {
        return this._u8(0x20 | x);
      } else if (24 <= x && x <= 255) {
        this._u8(0x20 | 24);
        return this._u8(x);
      } else if (0x100 <= x && x <= 0xFFFF) {
        this._u8(0x20 | 25);
        return this._u16(x);
      } else if (0x10000 <= x && x <= 0xFFFFFFFF) {
        this._u8(0x20 | 26);
        return this._u32(x);
      } else {
        throw new RangeError('Invalid i32');
      }
    };

    Encoder.prototype.i64 = function(x) {
      if (x >= 0) {
        return this._u64(x);
      }
      x = -1 - x;
      if (0 <= x && x <= 23) {
        return this._u8(0x20 | x);
      } else if (24 <= x && x <= 255) {
        this._u8(0x20 | 24);
        return this._u8(x);
      } else if (0x100 <= x && x <= 0xFFFF) {
        this._u8(0x20 | 25);
        return this._u16(x);
      } else if (0x10000 <= x && x <= 0xFFFFFFFF) {
        this._u8(0x20 | 26);
        return this._u32(x);
      } else if (x <= Number.MAX_SAFE_INTEGER) {
        this._u8(0x20 | 27);
        return this._u64(x);
      } else {
        throw new RangeError('Invalid i64');
      }
    };

    Encoder.prototype.f32 = function(x) {
      this._u8(0xE0 | 26);
      return this._f32(x);
    };

    Encoder.prototype.f64 = function(x) {
      this._u8(0xE0 | 27);
      return this._f64(x);
    };

    Encoder.prototype.bool = function(x) {
      return this._u8(0xE0 | (x ? 21 : 20));
    };

    Encoder.prototype.bytes = function(x) {
      this._write_type_and_len(Types.prototype.BYTES, x.byteLength);
      return this._bytes(x);
    };

    Encoder.prototype.text = function(x) {
      var utf8;
      utf8 = unescape(encodeURIComponent(x));
      this._write_type_and_len(Types.prototype.TEXT, utf8.length);
      return this._bytes(new Uint8Array(utf8.split('').map(function(c) {
        return c.charCodeAt(0);
      })));
    };

    Encoder.prototype["null"] = function() {
      return this._u8(0xE0 | 22);
    };

    Encoder.prototype.undefined = function() {
      return this._u8(0xE0 | 23);
    };

    Encoder.prototype.array = function(len) {
      return this._write_type_and_len(Types.prototype.ARRAY, len);
    };

    Encoder.prototype.array_begin = function() {
      return this._u8(0x9F);
    };

    Encoder.prototype.array_end = function() {
      return this._u8(0xFF);
    };

    Encoder.prototype.object = function(len) {
      return this._write_type_and_len(Types.prototype.OBJECT, len);
    };

    Encoder.prototype.object_begin = function() {
      return this._u8(0xBF);
    };

    Encoder.prototype.object_end = function() {
      return this._u8(0xFF);
    };

    return Encoder;

  })();

}).call(this);


/***/ },
/* 39 */
/***/ function(module, exports) {



/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.11.1
(function() {
  module.exports = {
    errors: {
      ProteusError: __webpack_require__(6),
      DecodeError: __webpack_require__(10),
      DecryptError: __webpack_require__(11)
    },
    keys: {
      IdentityKey: __webpack_require__(7),
      IdentityKeyPair: __webpack_require__(12),
      KeyPair: __webpack_require__(5),
      PreKeyAuth: __webpack_require__(25),
      PreKeyBundle: __webpack_require__(18),
      PreKey: __webpack_require__(17),
      PublicKey: __webpack_require__(4),
      SecretKey: __webpack_require__(19)
    },
    message: {
      Message: __webpack_require__(14),
      CipherMessage: __webpack_require__(8),
      PreKeyMessage: __webpack_require__(15),
      Envelope: __webpack_require__(13)
    },
    session: {
      PreKeyStore: __webpack_require__(26),
      Session: __webpack_require__(27)
    }
  };

}).call(this);


/***/ }
/******/ ])});;
//# sourceMappingURL=proteus.js.map